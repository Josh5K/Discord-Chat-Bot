"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Decorators_1 = require("../../Toolkit/Decorators");
const BaseAPI_1 = require("../BaseAPI");
const PrivilegedUser_1 = require("./PrivilegedUser");
const _1 = require("./");
const ObjectTools_1 = require("../../Toolkit/ObjectTools");
const UserTools_1 = require("../../Toolkit/UserTools");
const EmoteSetList_1 = require("../Channel/EmoteSetList");
const UserSubscription_1 = require("./UserSubscription");
const errors_1 = require("request-promise-native/errors");
const NotSubscribed_1 = require("../NotSubscribed");
const NoSubscriptionProgram_1 = require("../NoSubscriptionProgram");
const UserFollow_1 = require("./UserFollow");
const NotSubscribed_2 = require("./NotSubscribed");
const UserBlock_1 = require("./UserBlock");
let UserAPI = class UserAPI extends BaseAPI_1.default {
    constructor() {
        super(...arguments);
        this._userByNameCache = new Map;
    }
    getMe() {
        return __awaiter(this, void 0, void 0, function* () {
            return new PrivilegedUser_1.default(yield this._client.apiCall({ url: 'user', scope: 'user_read' }), this._client);
        });
    }
    getUser(user) {
        return __awaiter(this, void 0, void 0, function* () {
            return new _1.default(yield this._client.apiCall({ url: `users/${UserTools_1.default.getUserId(user)}` }), this._client);
        });
    }
    // not using the decorator's cache here as users-by-name is slightly more complex to cache
    getUserByName(userName) {
        return __awaiter(this, void 0, void 0, function* () {
            this._cleanUserCache();
            if (this._userByNameCache.has(userName)) {
                return this._userByNameCache.get(userName).value;
            }
            const { users } = yield this._client.apiCall({ url: 'users', query: { login: userName } });
            if (users.length === 0) {
                throw new Error('user not found');
            }
            const user = new _1.default(users[0], this._client);
            this._userByNameCache.set(userName, {
                value: user,
                expires: Date.now() + 3600 * 1000
            });
            return user;
        });
    }
    getUsersByNames(userNames) {
        return __awaiter(this, void 0, void 0, function* () {
            this._cleanUserCache();
            userNames = userNames.map(name => name.toLowerCase());
            const cachedEntries = Array.from(this._userByNameCache.entries()).filter(([key, val]) => userNames.includes(key));
            const cachedObject = ObjectTools_1.default.entriesToObject(cachedEntries);
            const cachedUsers = ObjectTools_1.default.map(cachedObject, entry => entry.value);
            const toFetch = userNames.filter(name => !(name in cachedUsers));
            if (!toFetch.length) {
                return cachedUsers;
            }
            const usersData = yield this._client.apiCall({ url: 'users', query: { login: toFetch.join(',') } });
            const usersArr = usersData.users.map((data) => new _1.default(data, this._client));
            usersArr.forEach(user => this._userByNameCache.set(user.userName, {
                value: user,
                expires: Date.now() + 3600 * 1000
            }));
            const users = ObjectTools_1.default.indexBy(usersArr, 'userName');
            return Object.assign({}, cachedUsers, users);
        });
    }
    getUserEmotes(user) {
        return __awaiter(this, void 0, void 0, function* () {
            let userId;
            if (user) {
                userId = UserTools_1.default.getUserId(user);
            }
            else {
                const tokenInfo = yield this._client.getTokenInfo();
                if (!tokenInfo.valid) {
                    throw new Error('authorization necessary to get emotes');
                }
                userId = tokenInfo.userId;
            }
            const data = yield this._client.apiCall({ url: `users/${userId}/emotes`, scope: 'user_subscriptions' });
            return new EmoteSetList_1.default(data.emoticon_sets, this._client);
        });
    }
    getSubscriptionData(user, toChannel) {
        return __awaiter(this, void 0, void 0, function* () {
            const userId = UserTools_1.default.getUserId(user);
            const channelId = UserTools_1.default.getUserId(toChannel);
            try {
                return new UserSubscription_1.default(yield this._client.apiCall({
                    url: `users/${userId}/subscriptions/${channelId}`,
                    scope: 'user_subscriptions'
                }), this._client);
            }
            catch (e) {
                if (e instanceof errors_1.StatusCodeError) {
                    if (e.statusCode === 404) {
                        throw new NotSubscribed_1.default(channelId, userId);
                    }
                    else if (e.statusCode === 422) {
                        throw new NoSubscriptionProgram_1.default(channelId);
                    }
                }
                throw e;
            }
        });
    }
    getFollowedChannels(user, page, limit, orderBy, orderDirection) {
        return __awaiter(this, void 0, void 0, function* () {
            const userId = UserTools_1.default.getUserId(user);
            let query = {};
            if (page) {
                query.offset = ((page - 1) * (limit || 25)).toString();
            }
            if (limit) {
                query.limit = limit.toString();
            }
            if (orderBy) {
                query.sortby = orderBy;
            }
            if (orderDirection) {
                query.direction = orderDirection;
            }
            const data = yield this._client.apiCall({
                url: `users/${userId}/follows/channels`, query
            });
            return data.follows.map((follow) => new UserFollow_1.default(follow, this._client));
        });
    }
    getFollowedChannel(user, channel) {
        return __awaiter(this, void 0, void 0, function* () {
            const userId = UserTools_1.default.getUserId(user);
            const channelId = UserTools_1.default.getUserId(channel);
            try {
                const data = yield this._client.apiCall({ url: `users/${userId}/follows/channels/${channelId}` });
                return new UserFollow_1.default(data, this._client);
            }
            catch (e) {
                if (e instanceof errors_1.StatusCodeError) {
                    if (e.statusCode === 404) {
                        throw new NotSubscribed_2.default(channelId, userId);
                    }
                }
                throw e;
            }
        });
    }
    followChannel(user, channel, notifications) {
        return __awaiter(this, void 0, void 0, function* () {
            const userId = UserTools_1.default.getUserId(user);
            const channelId = UserTools_1.default.getUserId(channel);
            const data = yield this._client.apiCall({
                url: `users/${userId}/follows/channels/${channelId}`,
                method: 'PUT',
                scope: 'user_follows_edit',
                body: { notifications: Boolean(notifications).toString() }
            });
            return new UserFollow_1.default(data, this._client);
        });
    }
    unfollowChannel(user, channel) {
        return __awaiter(this, void 0, void 0, function* () {
            const userId = UserTools_1.default.getUserId(user);
            const channelId = UserTools_1.default.getUserId(channel);
            yield this._client.apiCall({
                url: `users/${userId}/follows/channels/${channelId}`,
                scope: 'user_follows_edit',
                method: 'DELETE'
            });
        });
    }
    getBlockedUsers(user, page, limit) {
        return __awaiter(this, void 0, void 0, function* () {
            const userId = UserTools_1.default.getUserId(user);
            let query = {};
            if (page) {
                query.offset = ((page - 1) * (limit || 25)).toString();
            }
            if (limit) {
                query.limit = limit.toString();
            }
            const data = yield this._client.apiCall({
                url: `users/${userId}/blocks`, query, scope: 'user_blocks_read'
            });
            return data.blocks.map((block) => new UserBlock_1.default(block, this._client));
        });
    }
    blockUser(user, userToBlock) {
        return __awaiter(this, void 0, void 0, function* () {
            const userId = UserTools_1.default.getUserId(user);
            const userIdToBlock = UserTools_1.default.getUserId(userToBlock);
            const data = yield this._client.apiCall({
                url: `users/${userId}/blocks/${userIdToBlock}`,
                method: 'PUT',
                scope: 'user_blocks_edit',
            });
            return new UserFollow_1.default(data, this._client);
        });
    }
    unblockUser(user, userToUnblock) {
        return __awaiter(this, void 0, void 0, function* () {
            const userId = UserTools_1.default.getUserId(user);
            const userIdToUnblock = UserTools_1.default.getUserId(userToUnblock);
            yield this._client.apiCall({
                url: `users/${userId}/blocks/${userIdToUnblock}`,
                method: 'DELETE',
                scope: 'user_blocks_edit'
            });
        });
    }
    _cleanUserCache() {
        const now = Date.now();
        this._userByNameCache.forEach((val, key) => {
            if (val.expires < now) {
                this._userByNameCache.delete(key);
            }
        });
    }
};
__decorate([
    Decorators_1.Cached(3600)
], UserAPI.prototype, "getMe", null);
__decorate([
    Decorators_1.Cached(3600)
], UserAPI.prototype, "getUser", null);
__decorate([
    Decorators_1.Cached(3600)
], UserAPI.prototype, "getUserEmotes", null);
__decorate([
    Decorators_1.Cached(3600)
], UserAPI.prototype, "getSubscriptionData", null);
__decorate([
    Decorators_1.Cached(300)
], UserAPI.prototype, "getFollowedChannels", null);
__decorate([
    Decorators_1.Cached(300)
], UserAPI.prototype, "getFollowedChannel", null);
__decorate([
    Decorators_1.ClearsCache('getFollowedChannels', 1),
    Decorators_1.ClearsCache('getFollowedChannel', 2)
], UserAPI.prototype, "followChannel", null);
__decorate([
    Decorators_1.ClearsCache('getFollowedChannels', 1),
    Decorators_1.ClearsCache('getFollowedChannel', 2)
], UserAPI.prototype, "unfollowChannel", null);
__decorate([
    Decorators_1.Cached(3600)
], UserAPI.prototype, "getBlockedUsers", null);
__decorate([
    Decorators_1.ClearsCache('getBlockedUsers', 1)
], UserAPI.prototype, "blockUser", null);
__decorate([
    Decorators_1.ClearsCache('getBlockedUsers', 1)
], UserAPI.prototype, "unblockUser", null);
UserAPI = __decorate([
    Decorators_1.Cacheable
], UserAPI);
exports.default = UserAPI;
//# sourceMappingURL=UserAPI.js.map