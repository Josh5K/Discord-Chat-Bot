"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const ircv3_1 = require("ircv3");
const UserTools_1 = require("../Toolkit/UserTools");
const _1 = require("./Capabilities/TwitchTags/");
const _2 = require("./Capabilities/TwitchCommands/");
const TwitchMembership_1 = require("./Capabilities/TwitchMembership");
const _3 = require("ircv3/lib/Message/MessageTypes/Commands/");
const ClearChat_1 = require("./Capabilities/TwitchCommands/MessageTypes/ClearChat");
const HostTarget_1 = require("./Capabilities/TwitchCommands/MessageTypes/HostTarget");
const RoomState_1 = require("./Capabilities/TwitchCommands/MessageTypes/RoomState");
const UserNotice_1 = require("./Capabilities/TwitchCommands/MessageTypes/UserNotice");
const Whisper_1 = require("./Capabilities/TwitchCommands/MessageTypes/Whisper");
const Decorators_1 = require("../Toolkit/Decorators");
const PrivateMessage_1 = require("./StandardCommands/PrivateMessage");
class ChatClient extends ircv3_1.Client {
    constructor(username, token, twitchClient, debugLevel = 0) {
        super({
            connection: {
                hostName: 'irc-ws.chat.twitch.tv',
                nick: username.toLowerCase(),
                password: `oauth:${token}`,
                secure: true
            },
            webSocket: true,
            debugLevel
        });
        this.onTimeout = this.registerEvent();
        this.onBan = this.registerEvent();
        this.onChatClear = this.registerEvent();
        this.onEmoteOnly = this.registerEvent();
        this.onFollowersOnly = this.registerEvent();
        this.onHost = this.registerEvent();
        this.onHosted = this.registerEvent();
        this.onJoin = this.registerEvent();
        this.onPart = this.registerEvent();
        this.onR9k = this.registerEvent();
        this.onUnhost = this.registerEvent();
        this.onSlow = this.registerEvent();
        this.onSubsOnly = this.registerEvent();
        this.onSub = this.registerEvent();
        this.onResub = this.registerEvent();
        this.onWhisper = this.registerEvent();
        // internal events to resolve promises and stuff
        this._onBanResult = this.registerEvent();
        this._onTimeoutResult = this.registerEvent();
        this._onUnbanResult = this.registerEvent();
        this._onColorResult = this.registerEvent();
        this._onCommercialResult = this.registerEvent();
        this._onEmoteOnlyResult = this.registerEvent();
        this._onEmoteOnlyOffResult = this.registerEvent();
        this._onFollowersOnlyResult = this.registerEvent();
        this._onFollowersOnlyOffResult = this.registerEvent();
        this._onHostResult = this.registerEvent();
        this._onUnhostResult = this.registerEvent();
        this._onModResult = this.registerEvent();
        this._onUnmodResult = this.registerEvent();
        this._onModsResult = this.registerEvent();
        this._onJoinResult = this.registerEvent();
        this._onR9kResult = this.registerEvent();
        this._onR9kOffResult = this.registerEvent();
        this._onSlowResult = this.registerEvent();
        this._onSlowOffResult = this.registerEvent();
        this._onSubsOnlyResult = this.registerEvent();
        this._onSubsOnlyOffResult = this.registerEvent();
        this._twitchClient = twitchClient;
        this.registerCapability(_1.default);
        this.registerCapability(_2.default);
        this.registerCapability(TwitchMembership_1.default);
        this.onMessage(ClearChat_1.default, ({ params: { channel, user }, tags }) => {
            if (user) {
                const duration = tags.get('ban-duration');
                const reason = tags.get('ban-reason');
                if (duration != null) {
                    // timeout
                    this.emit(this.onTimeout, channel, user, reason, Number(duration));
                    this.emit(this._onTimeoutResult, channel, user, reason, Number(duration));
                }
                else {
                    // ban
                    this.emit(this.onBan, channel, user, reason);
                }
            }
            else {
                // full chat clear
                this.emit(this.onChatClear, channel);
            }
        });
        this.onMessage(HostTarget_1.default, (hostMessage) => {
            const { params: { channel, targetAndViewers } } = hostMessage;
            const [target, viewers] = targetAndViewers.split(' ');
            if (target === '-') {
                // unhost
                this.emit(this._onUnhostResult, channel);
                this.emit(this.onUnhost, channel);
            }
            else {
                this.emit(this.onHost, channel, target, viewers ? Number(viewers) : undefined);
            }
        });
        this.onMessage(_3.ChannelJoin, (joinMessage) => {
            const { prefix, params: { channel } } = joinMessage;
            this.emit(this.onJoin, channel, prefix.nick);
        });
        this.onMessage(_3.ChannelPart, (partMessage) => {
            const { prefix, params: { channel } } = partMessage;
            this.emit(this.onPart, channel, prefix.nick);
        });
        this.onMessage(PrivateMessage_1.default, (msg) => {
            const { prefix, params: { target: channel, message } } = msg;
            if (prefix && prefix.nick === 'jtv') {
                // 1 = who hosted
                // 2 = auto-host or not
                // 3 = how many viewers (not always present)
                const match = message.match(ChatClient.HOST_MESSAGE_REGEX);
                if (match) {
                    this.emit(this.onHosted, channel, match[1], Boolean(match[2]), match[3] === '' ? Number(match[3]) : undefined);
                }
            }
        });
        this.onMessage(RoomState_1.default, (stateMessage) => {
            const { params: { channel }, tags } = stateMessage;
            let isInitial = false;
            if (tags.has('subs-only') && tags.has('slow')) {
                // this is the full state - so we just successfully joined
                this.emit(this._onJoinResult, channel, tags);
                isInitial = true;
            }
            if (tags.has('slow')) {
                const slowDelay = Number(tags.get('slow'));
                if (!slowDelay) {
                    this.emit(this._onSlowOffResult, channel);
                    if (!isInitial) {
                        this.emit(this.onSlow, channel, false);
                    }
                }
                else {
                    this.emit(this._onSlowResult, channel, slowDelay);
                    if (!isInitial) {
                        this.emit(this.onSlow, channel, true, slowDelay);
                    }
                }
            }
            if (tags.has('followers-only')) {
                const followDelay = Number(tags.get('followers-only'));
                if (followDelay === -1) {
                    this.emit(this._onFollowersOnlyOffResult, channel);
                    if (!isInitial) {
                        this.emit(this.onFollowersOnly, channel, false);
                    }
                }
                else {
                    this.emit(this._onFollowersOnlyResult, channel, followDelay);
                    if (!isInitial) {
                        this.emit(this.onFollowersOnly, channel, true, followDelay);
                    }
                }
            }
        });
        this.onMessage(UserNotice_1.default, (userNotice) => {
            const { prefix, params: { channel, message }, tags } = userNotice;
            const messageType = tags.get('msg-id');
            if (messageType === 'sub' || messageType === 'resub') {
                const event = messageType === 'sub' ? this.onSub : this.onResub;
                const plan = tags.get('msg-param-sub-plan');
                const subInfo = {
                    plan: plan,
                    planName: tags.get('msg-param-sub-plan-name'),
                    isPrime: plan === 'Prime',
                    streak: Number(tags.get('msg-param-months')),
                    message: message
                };
                this.emit(event, channel, prefix.nick, subInfo, userNotice);
            }
        });
        this.onMessage(Whisper_1.default, (whisper) => {
            this.emit(this.onWhisper, whisper.prefix.nick, whisper.params.message, whisper);
        });
        this.onMessage(_3.Notice, (notice) => {
            const { params: { target: channel, message }, tags } = notice;
            const messageType = tags.get('msg-id');
            // this event handler involves a lot of parsing strings you shouldn't parse...
            // but Twitch doesn't give us the required info in tags (╯°□°）╯︵ ┻━┻
            // (this code also might not do the right thing with foreign character display names...)
            switch (messageType) {
                // ban
                case 'already_banned': {
                    const match = message.split(' ');
                    const user = (match && /^\w+$/.test(match[0])) ? match[0] : undefined;
                    this.emit(this._onBanResult, channel, user, messageType);
                    break;
                }
                case 'bad_ban_self': {
                    this.emit(this._onBanResult, channel, this._userName, messageType);
                    break;
                }
                case 'bad_ban_broadcaster': {
                    this.emit(this._onBanResult, channel, UserTools_1.default.toUserName(channel), messageType);
                    break;
                }
                case 'bad_ban_admin':
                case 'bad_ban_global_mod':
                case 'bad_ban_staff': {
                    const match = message.match(/^You cannot ban (?:\w+ )+?(\w+)\.$/);
                    this.emit(this._onBanResult, channel, match ? match[1].toLowerCase() : undefined, messageType);
                    break;
                }
                case 'ban_success': {
                    const match = message.split(' ');
                    const user = (match && /^\w+$/.test(match[0])) ? match[0] : undefined;
                    this.emit(this._onBanResult, channel, user);
                    break;
                }
                // unban
                case 'bad_unban_no_ban': {
                    const match = message.split(' ');
                    const user = (match && /^\w+$/.test(match[0])) ? match[0] : undefined;
                    this.emit(this._onUnbanResult, channel, user, messageType);
                    break;
                }
                case 'unban_success': {
                    const match = message.split(' ');
                    const user = (match && /^\w+$/.test(match[0])) ? match[0] : undefined;
                    this.emit(this._onUnbanResult, channel, user);
                    break;
                }
                // color
                case 'turbo_only_color': {
                    this.emit(this._onColorResult, messageType);
                    break;
                }
                case 'color_changed': {
                    this.emit(this._onColorResult);
                    break;
                }
                // commercial
                case 'bad_commercial_error': {
                    this.emit(this._onCommercialResult, channel, messageType);
                    break;
                }
                case 'commercial_success': {
                    this.emit(this._onCommercialResult, channel);
                    break;
                }
                // emote only
                case 'already_emote_only_on': {
                    this.emit(this._onEmoteOnlyResult, channel, messageType);
                    break;
                }
                case 'emote_only_on': {
                    this.emit(this._onEmoteOnlyResult, channel);
                    this.emit(this.onEmoteOnly, channel, true);
                    break;
                }
                // emote only off
                case 'already_emote_only_off': {
                    this.emit(this._onEmoteOnlyOffResult, channel, messageType);
                    break;
                }
                case 'emote_only_off': {
                    this.emit(this._onEmoteOnlyOffResult, channel);
                    this.emit(this.onEmoteOnly, channel, false);
                    break;
                }
                // host
                case 'bad_host_hosting':
                case 'bad_host_rate_exceeded':
                case 'bad_host_error': {
                    this.emit(this._onHostResult, channel, messageType);
                    break;
                }
                case 'hosts_remaining': {
                    const remainingHostsFromChar = +message[0];
                    const remainingHosts = isNaN(remainingHostsFromChar) ? 0 : Number(remainingHostsFromChar);
                    this.emit(this._onHostResult, channel, remainingHosts);
                    break;
                }
                // unhost (only fails, success is handled by HOSTTARGET)
                case 'not_hosting': {
                    this.emit(this._onUnhostResult, channel, messageType);
                    break;
                }
                // join (success is handled when ROOMSTATE comes in)
                case 'msg_channel_suspended': {
                    this.emit(this._onJoinResult, channel, undefined, messageType);
                    break;
                }
                // mod
                case 'bad_mod_banned':
                case 'bad_mod_mod': {
                    const match = message.split(' ');
                    const user = (match && /^\w+$/.test(match[0])) ? match[0] : undefined;
                    this.emit(this._onModResult, channel, user, messageType);
                    break;
                }
                case 'mod_success': {
                    const match = message.match(/^You have added (\w+) /);
                    this.emit(this._onModResult, channel, match ? match[1] : undefined);
                    break;
                }
                // unmod
                case 'bad_unmod_mod': {
                    const match = message.split(' ');
                    const user = (match && /^\w+$/.test(match[0])) ? match[0] : undefined;
                    this.emit(this._onUnmodResult, channel, user, messageType);
                    break;
                }
                case 'unmod_success': {
                    const match = message.match(/^You have removed (\w+) /);
                    this.emit(this._onUnmodResult, channel, match ? match[1] : undefined);
                    break;
                }
                // mods
                case 'no_mods': {
                    this.emit(this._onModsResult, channel, []);
                    break;
                }
                case 'room_mods': {
                    const [, modList] = message.split(': ');
                    const mods = modList.split(', ');
                    this.emit(this._onModsResult, channel, mods);
                    break;
                }
                // r9k
                case 'already_r9k_on': {
                    this.emit(this._onR9kResult, channel, messageType);
                    break;
                }
                case 'r9k_on': {
                    this.emit(this._onR9kResult, channel);
                    this.emit(this.onR9k, channel, true);
                    break;
                }
                // r9k off
                case 'already_r9k_off': {
                    this.emit(this._onR9kOffResult, channel, messageType);
                    break;
                }
                case 'r9k_off': {
                    this.emit(this._onR9kOffResult, channel);
                    this.emit(this.onR9k, channel, false);
                    break;
                }
                // subs only
                case 'already_subs_on': {
                    this.emit(this._onSubsOnlyResult, channel, messageType);
                    break;
                }
                case 'subs_on': {
                    this.emit(this._onSubsOnlyResult, channel);
                    this.emit(this.onSubsOnly, channel, true);
                    break;
                }
                // subs only off
                case 'already_subs_off': {
                    this.emit(this._onSubsOnlyOffResult, channel, messageType);
                    break;
                }
                case 'subs_off': {
                    this.emit(this._onSubsOnlyOffResult, channel);
                    this.emit(this.onSubsOnly, channel, false);
                    break;
                }
                // timeout (only fails, success is handled by CLEARCHAT)
                case 'bad_timeout_self': {
                    this.emit(this._onTimeoutResult, channel, this._userName, undefined, undefined, messageType);
                    break;
                }
                case 'bad_timeout_broadcaster': {
                    this.emit(this._onTimeoutResult, channel, UserTools_1.default.toUserName(channel), undefined, undefined, messageType);
                    break;
                }
                case 'bad_timeout_admin':
                case 'bad_timeout_global_mod':
                case 'bad_timeout_staff': {
                    const match = message.match(/^You cannot ban (?:\w+ )+?(\w+)\.$/);
                    this.emit(this._onTimeoutResult, channel, match ? match[1].toLowerCase() : undefined, undefined, undefined, messageType);
                    break;
                }
                case 'cmds_available': {
                    // do we really care?
                    break;
                }
                // there's other messages that show us the following things...
                // ...like ROOMSTATE...
                case 'followers_on':
                case 'followers_on_zero':
                case 'followers_off':
                case 'slow_on':
                case 'slow_off':
                // ...and CLEARCHAT...
                case 'timeout_success':
                // ...and HOSTTARGET
                case 'host_off':
                case 'host_on':
                case 'host_target_went_offline': {
                    break;
                }
                case 'unrecognized_cmd': {
                    break;
                }
                case null: {
                    // this might be one of these weird authentication error notices that don't have a msg-id...
                    if (message === 'Login authentication failed'
                        || message === 'Improperly formatted AUTH'
                        || message === 'Invalid NICK') {
                        this._connection.disconnect();
                    }
                    break;
                }
                default: {
                    if (!messageType || messageType.substr(0, 6) !== 'usage_') {
                        console.warn(`Unrecognized notice ID: '${messageType}'`);
                    }
                }
            }
        });
    }
    registerCoreMessageTypes() {
        super.registerCoreMessageTypes();
        this.registerMessageType(PrivateMessage_1.default);
    }
}
ChatClient.HOST_MESSAGE_REGEX = /(\w+) is now ((?:auto[- ])?)hosting you(?: for (?:up to )?(\d+))?/;
__decorate([
    Decorators_1.NonEnumerable
], ChatClient.prototype, "_twitchClient", void 0);
exports.default = ChatClient;
//# sourceMappingURL=ChatClient.js.map