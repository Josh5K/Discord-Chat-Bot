"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
function Cacheable(cls) {
    return class extends cls {
        constructor() {
            super(...arguments);
            this.cache = new Map;
        }
        getFromCache(cacheKey) {
            this._cleanCache();
            if (this.cache.has(cacheKey)) {
                const entry = this.cache.get(cacheKey);
                if (entry) {
                    return entry.value;
                }
            }
            return undefined;
        }
        setCache(cacheKey, value, timeInSeconds) {
            this.cache.set(cacheKey, {
                value, expires: Date.now() + (timeInSeconds * 1000)
            });
        }
        removeFromCache(cacheKey, prefix) {
            let internalCacheKey;
            if (typeof cacheKey === 'string') {
                internalCacheKey = cacheKey;
                if (!internalCacheKey.endsWith('/')) {
                    internalCacheKey += '/';
                }
            }
            else {
                const propName = cacheKey.shift();
                internalCacheKey = createCacheKey(propName, cacheKey, prefix);
            }
            if (prefix) {
                this.cache.forEach((val, key) => {
                    if (key.startsWith(internalCacheKey)) {
                        this.cache.delete(key);
                    }
                });
            }
            else {
                this.cache.delete(internalCacheKey);
            }
        }
        _cleanCache() {
            const now = Date.now();
            this.cache.forEach((val, key) => {
                if (val.expires < now) {
                    this.cache.delete(key);
                }
            });
        }
    };
}
exports.Cacheable = Cacheable;
// tslint:disable-next-line:no-any
function createCacheKey(propName, params, prefix) {
    // tslint:disable-next-line:no-any
    function createSingleCacheKey(param) {
        // noinspection FallThroughInSwitchStatementJS
        switch (typeof param) {
            case 'undefined': {
                return '';
            }
            case 'object': {
                if (param === null) {
                    return '';
                }
                if ('cacheKey' in param) {
                    return param.cacheKey;
                }
            }
            // tslint:disable-next-line:no-switch-case-fall-through
            default: {
                return param.toString();
            }
        }
    }
    // tslint:disable-next-line:no-any
    return [propName, ...params.map(createSingleCacheKey)].join('/') + (prefix ? '/' : '');
}
exports.createCacheKey = createCacheKey;
function Cached(timeInSeconds = Infinity, cacheFailures = false) {
    // tslint:disable-next-line:no-any
    return function (target, propName, descriptor) {
        const origFn = descriptor.value;
        // tslint:disable-next-line:no-any
        descriptor.value = function (...params) {
            return __awaiter(this, void 0, void 0, function* () {
                const cacheKey = createCacheKey(propName, params);
                const cachedValue = this.getFromCache(cacheKey);
                if (cachedValue) {
                    return cachedValue;
                }
                const result = yield origFn.apply(this, params);
                if (result != null || cacheFailures) {
                    this.setCache(cacheKey, result, timeInSeconds);
                }
                return result;
            });
        };
        return descriptor;
    };
}
exports.Cached = Cached;
function CachedGetter(timeInSeconds = Infinity) {
    // tslint:disable-next-line:no-any
    return function (target, propName, descriptor) {
        if (descriptor.get) {
            const origFn = descriptor.get;
            // tslint:disable-next-line:no-any
            descriptor.get = function (...params) {
                const cacheKey = createCacheKey(propName, params);
                const cachedValue = this.getFromCache(cacheKey);
                if (cachedValue) {
                    return cachedValue;
                }
                const result = origFn.apply(this, params);
                this.setCache(cacheKey, result, timeInSeconds);
                return result;
            };
        }
        return descriptor;
    };
}
exports.CachedGetter = CachedGetter;
function ClearsCache(cacheName, numberOfArguments) {
    // tslint:disable-next-line:no-any
    return function (target, propName, descriptor) {
        const origFn = descriptor.value;
        // tslint:disable-next-line:no-any
        descriptor.value = function (...params) {
            return __awaiter(this, void 0, void 0, function* () {
                const result = yield origFn.apply(this, params);
                const args = numberOfArguments == null ? params.slice() : params.slice(0, numberOfArguments);
                this.removeFromCache([cacheName, ...args], true);
                return result;
            });
        };
        return descriptor;
    };
}
exports.ClearsCache = ClearsCache;
// tslint:disable-next-line:no-any
function NonEnumerable(target, key) {
    // first property defined in prototype, that's why we use getters/setters
    // (otherwise assignment in object will override property in prototype)
    Object.defineProperty(target, key, {
        get: function () {
            return undefined;
        },
        // tslint:disable-next-line:no-any
        set: function (val) {
            // here we have reference to instance and can set property directly to it
            Object.defineProperty(this, key, {
                value: val,
                writable: true,
                enumerable: false,
            });
        },
        enumerable: false,
    });
}
exports.NonEnumerable = NonEnumerable;
//# sourceMappingURL=Decorators.js.map