"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const WebSocketConnection_1 = require("./Connection/WebSocketConnection");
const DirectConnection_1 = require("./Connection/DirectConnection");
const StringTools_1 = require("./Toolkit/StringTools");
const Message_1 = require("./Message/Message");
const ObjectTools_1 = require("./Toolkit/ObjectTools");
const MessageCollector_1 = require("./Message/MessageCollector");
const MessageTypes = require("./Message/MessageTypes");
const CoreCapabilities = require("./Capability/CoreCapabilities");
const randomstring = require("randomstring");
const typed_event_emitter_1 = require("typed-event-emitter");
const Commands_1 = require("./Message/MessageTypes/Commands");
const Numerics_1 = require("./Message/MessageTypes/Numerics");
const ClientQuit_1 = require("./Message/MessageTypes/Commands/ClientQuit");
class Client extends typed_event_emitter_1.EventEmitter {
    constructor({ connection, webSocket, channelTypes, debugLevel }) {
        super();
        this._registered = false;
        this._supportsCapabilities = true;
        this._events = new Map();
        this._registeredMessageTypes = new Map;
        // emitted events
        this.onConnect = this.registerEvent();
        this.onRegister = this.registerEvent();
        this.onDisconnect = this.registerEvent();
        this.onPrivmsg = this.registerEvent();
        this.onAction = this.registerEvent();
        this.onNotice = this.registerEvent();
        this.onCtcp = this.registerEvent();
        this.onCtcpReply = this.registerEvent();
        // sane defaults based on RFC 1459
        this._channelTypes = '#&';
        this._supportedUserModes = 'iwso';
        this._supportedChannelModes = {
            list: 'b',
            alwaysWithParam: 'ovk',
            paramWhenSet: 'l',
            noParam: 'imnpst'
        };
        this._supportedFeatures = {};
        this._collectors = [];
        this._clientCapabilities = new Map;
        this._serverCapabilities = new Map;
        this._negotiatedCapabilities = new Map;
        this._pingOnInactivity = connection.pingOnInactivity || 60;
        this._pingTimeout = connection.pingTimeout || 10;
        this._debugLevel = debugLevel || 0;
        if (webSocket) {
            this._connection = new WebSocketConnection_1.default(connection);
        }
        else {
            this._connection = new DirectConnection_1.default(connection);
        }
        this.registerCoreMessageTypes();
        for (const cap of Object.values(CoreCapabilities)) {
            this.registerCapability(cap);
        }
        this._connection.on('connect', () => {
            this.sendMessageAndCaptureReply(Commands_1.CapabilityNegotiation, {
                command: 'LS',
                version: '302'
            }).then((capReply) => {
                if (!capReply.length || !(capReply[0] instanceof Commands_1.CapabilityNegotiation)) {
                    return;
                }
                this._supportsCapabilities = true;
                const capLists = capReply.map(line => ObjectTools_1.default.fromArray(line.params.capabilities.split(' '), (part) => {
                    if (!part) {
                        return {};
                    }
                    const [cap, param] = part.split('=', 2);
                    return {
                        [cap]: {
                            name: cap,
                            param: param || true
                        }
                    };
                }));
                this._serverCapabilities = new Map(Object.entries(Object.assign({}, ...capLists)));
                const capabilitiesToNegotiate = capLists.map(list => {
                    const capNames = Object.keys(list);
                    return Array.from(this._clientCapabilities.entries())
                        .filter(([name]) => capNames.includes(name))
                        .map(([, cap]) => cap);
                });
                this._negotiateCapabilityBatch(capabilitiesToNegotiate).then(() => {
                    this.sendMessage(Commands_1.CapabilityNegotiation, { command: 'END' });
                    this._registered = true;
                    this.emit(this.onRegister);
                });
            });
            if (connection.password) {
                this.sendMessage(Commands_1.Password, { password: connection.password });
            }
            this.sendMessage(Commands_1.NickChange, { nick: this._nick });
            this.sendMessage(Commands_1.UserRegistration, {
                user: this._userName,
                mode: '8',
                unused: '*',
                realName: this._realName
            });
        });
        this._connection.on('lineReceived', (line) => {
            const timestamp = (new Date()).toLocaleString();
            // tslint:disable:no-console
            if (this._debugLevel >= 1) {
                console.log(`[${timestamp}] > recv: \`${line}\``);
            }
            let parsedMessage = Message_1.default.parse(line, this);
            if (this._debugLevel >= 2) {
                console.log(`[${timestamp}] > recv parsed:`, parsedMessage);
            }
            this._startPingCheckTimer();
            this.handleEvents(parsedMessage);
            // tslint:enable:no-console
        });
        this.onMessage(Commands_1.CapabilityNegotiation, ({ params: { command, capabilities } }) => {
            // tslint:disable-next-line:switch-default
            switch (command.toUpperCase()) {
                case 'NEW': {
                    const capList = ObjectTools_1.default.fromArray(capabilities.split(' '), (part) => {
                        if (!part) {
                            return {};
                        }
                        const [cap, param] = part.split('=', 2);
                        return {
                            [cap]: {
                                name: cap,
                                param: param || true
                            }
                        };
                    });
                    for (const [name, cap] of Object.entries(capList)) {
                        this._serverCapabilities.set(name, cap);
                    }
                    const capNames = Object.keys(capList);
                    this._negotiateCapabilities(Array.from(this._clientCapabilities.entries())
                        .filter(([name]) => capNames.includes(name))
                        .map(([, cap]) => cap));
                    break;
                }
                case 'DEL': {
                    for (const cap of capabilities.split(' ')) {
                        this._serverCapabilities.delete(cap);
                        this._negotiatedCapabilities.delete(cap);
                    }
                    break;
                }
            }
        });
        this.onMessage(Commands_1.Ping, ({ params: { message } }) => {
            this.sendMessage(Commands_1.Pong, { message });
        });
        this.onMessage(Numerics_1.Reply001Welcome, () => {
            if (!this._supportsCapabilities) {
                this._registered = true;
                this.emit(this.onRegister);
            }
        });
        this.onMessage(Numerics_1.Reply004ServerInfo, ({ params: { userModes } }) => {
            if (userModes) {
                this._supportedUserModes = userModes;
            }
        });
        this.onMessage(Numerics_1.Reply005ISupport, ({ params: { supports } }) => {
            this._supportedFeatures = Object.assign(this._supportedFeatures, ObjectTools_1.default.fromArray(supports.split(' '), (part) => {
                const [support, param] = part.split('=', 2);
                return { [support]: param || true };
            }));
        });
        this.onMessage(Numerics_1.Error462AlreadyRegistered, () => {
            // what, I thought we are not registered yet?
            if (!this._registered) {
                // screw this, we are now.
                this._registered = true;
                this.emit(this.onRegister);
            }
        });
        this.onMessage(Commands_1.PrivateMessage, (msg) => {
            const { params: { target, message } } = msg;
            const ctcpMessage = StringTools_1.decodeCtcp(message);
            const nick = msg.prefix && msg.prefix.nick;
            if (ctcpMessage) {
                if (ctcpMessage.command === 'ACTION') {
                    this.emit(this.onAction, target, nick, ctcpMessage.message, msg);
                }
                else {
                    this.emit(this.onCtcp, target, nick, ctcpMessage.command, ctcpMessage.message, msg);
                }
            }
            this.emit(this.onPrivmsg, target, nick, message, msg);
        });
        this.onMessage(Commands_1.Notice, (msg) => {
            const { params: { target, message } } = msg;
            const ctcpMessage = StringTools_1.decodeCtcp(message);
            const nick = msg.prefix && msg.prefix.nick;
            if (ctcpMessage) {
                this.emit(this.onCtcpReply, target, nick, ctcpMessage.command, ctcpMessage.message, msg);
            }
            this.emit(this.onNotice, target, nick, message, msg);
        });
        this.onRegister(() => this._startPingCheckTimer());
        this._connection.on('disconnect', (reason) => {
            this._registered = false;
            clearTimeout(this._pingCheckTimer);
            clearTimeout(this._pingTimeoutTimer);
            this.emit(this.onDisconnect, reason);
        });
        this._nick = connection.nick;
        this._userName = connection.userName || connection.nick;
        this._realName = connection.realName || connection.nick;
        if (channelTypes) {
            this._channelTypes = channelTypes;
        }
    }
    pingCheck() {
        const token = randomstring.generate(16);
        const handler = this.onMessage(Commands_1.Pong, ({ params: { message } }) => {
            if (message === token) {
                clearTimeout(this._pingTimeoutTimer);
                this.removeMessageListener(handler);
            }
        });
        this._pingTimeoutTimer = setTimeout(() => {
            this.removeMessageListener(handler);
            this.reconnect('Ping timeout');
        }, this._pingTimeout * 1000);
        this.sendMessage(Commands_1.Ping, { message: token });
    }
    reconnect(message) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.quit(message);
            return this.connect();
        });
    }
    registerMessageType(cls) {
        if (cls.COMMAND !== '') {
            this._registeredMessageTypes.set(cls.COMMAND.toUpperCase(), cls);
        }
    }
    knowsCommand(command) {
        return this._registeredMessageTypes.has(command.toUpperCase());
    }
    getCommandClass(command) {
        return this._registeredMessageTypes.get(command.toUpperCase());
    }
    registerCoreMessageTypes() {
        ObjectTools_1.default.forEach(MessageTypes.Commands, (type) => {
            this.registerMessageType(type);
        });
        ObjectTools_1.default.forEach(MessageTypes.Numerics, (type) => {
            this.registerMessageType(type);
        });
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            this._supportsCapabilities = false;
            this._negotiatedCapabilities = new Map;
            yield this._connection.connect();
            this.emit(this.onConnect);
        });
    }
    _negotiateCapabilityBatch(capabilities) {
        return __awaiter(this, void 0, void 0, function* () {
            return Promise.all(capabilities.filter(list => list.length).map((capList) => this._negotiateCapabilities(capList)));
        });
    }
    _negotiateCapabilities(capList) {
        return __awaiter(this, void 0, void 0, function* () {
            const mappedCapList = ObjectTools_1.default.fromArray(capList, cap => ({ [cap.name]: cap }));
            const messages = yield this.sendMessageAndCaptureReply(Commands_1.CapabilityNegotiation, {
                command: 'REQ',
                capabilities: capList.map(cap => cap.name).join(' ')
            });
            const capReply = messages.shift();
            if (!capReply) {
                throw new Error('capability negotiation failed unexpectedly without any reply');
            }
            if (!(capReply instanceof Commands_1.CapabilityNegotiation)) {
                throw new Error(`capability negotiation failed unexpectedly with "${capReply.command}" command`);
            }
            if (capReply.params.command === 'ACK') {
                // filter is necessary because some networks seem to add trailing spaces...
                const newCapNames = capReply.params.capabilities.split(' ').filter(c => c);
                const newNegotiatedCaps = newCapNames.map(capName => mappedCapList[capName]);
                for (const newCap of newNegotiatedCaps) {
                    let mergedCap = this._clientCapabilities.get(newCap.name);
                    mergedCap.param = newCap.param;
                    this._negotiatedCapabilities.set(mergedCap.name, mergedCap);
                }
                return newNegotiatedCaps;
            }
            else {
                return new Error('capabilities failed to negotiate');
            }
        });
    }
    registerCapability(cap) {
        return __awaiter(this, void 0, void 0, function* () {
            this._clientCapabilities.set(cap.name, cap);
            if (cap.messageTypes) {
                for (const messageType of cap.messageTypes) {
                    this.registerMessageType(messageType);
                }
            }
            if (this._serverCapabilities.has(cap.name)) {
                return this._negotiateCapabilities([cap]);
            }
            return [];
        });
    }
    send(message) {
        const line = message.toString();
        const timestamp = (new Date()).toLocaleString();
        if (this._debugLevel >= 1) {
            // tslint:disable-next-line:no-console
            console.log(`[${timestamp}] < send: \`${line}\``);
        }
        this._connection.sendLine(line);
    }
    onMessage(type, handler, handlerName) {
        const commandName = typeof type === 'string' ? type : type.COMMAND;
        if (!this._events.has(commandName)) {
            this._events.set(commandName, new Map);
        }
        let handlerList = this._events.get(commandName);
        if (!handlerName) {
            do {
                handlerName = `${commandName}:${StringTools_1.padLeft(Math.random() * 10000, 4, '0')}`;
            } while (handlerList.has(handlerName));
        }
        handlerList.set(handlerName, handler);
        return handlerName;
    }
    removeMessageListener(handlerName) {
        const [commandName] = handlerName.split(':');
        if (!this._events.has(commandName)) {
            return;
        }
        this._events.get(commandName).delete(handlerName);
    }
    createMessage(type, params) {
        return type.create(this, params);
    }
    sendMessage(type, params) {
        this.createMessage(type, params).send();
    }
    sendMessageAndCaptureReply(type, params) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.createMessage(type, params).sendAndCaptureReply();
        });
    }
    get channelTypes() {
        return this._channelTypes;
    }
    get supportedChannelModes() {
        return this._supportedChannelModes;
    }
    get isConnected() {
        return this._connection.isConnected;
    }
    get isConnecting() {
        return this._connection.isConnecting;
    }
    get isRegistered() {
        return this._registered;
    }
    collect(originalMessage, ...types) {
        const collector = new MessageCollector_1.default(this, originalMessage, ...types);
        this._collectors.push(collector);
        return collector;
    }
    stopCollect(collector) {
        this._collectors.splice(this._collectors.findIndex(value => value === collector), 1);
    }
    // convenience methods
    join(channel, key) {
        this.sendMessage(Commands_1.ChannelJoin, { channel, key });
    }
    part(channel) {
        this.sendMessage(Commands_1.ChannelPart, { channel });
    }
    quit(message) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise(resolve => {
                this.sendMessage(ClientQuit_1.default, { message });
                const handler = () => {
                    this._connection.removeListener('disconnect', handler);
                    resolve();
                };
                this._connection.addListener('disconnect', handler);
                this._connection.disconnect();
            });
        });
    }
    // event helper
    handleEvents(message) {
        this._collectors.some(collector => collector.collect(message));
        const handlers = this._events.get(message.constructor.COMMAND);
        if (!handlers) {
            return;
        }
        for (const handler of handlers.values()) {
            handler(message);
        }
    }
    _startPingCheckTimer() {
        clearTimeout(this._pingCheckTimer);
        this._pingCheckTimer = setTimeout(() => this.pingCheck(), this._pingOnInactivity * 1000);
    }
}
exports.default = Client;
//# sourceMappingURL=Client.js.map