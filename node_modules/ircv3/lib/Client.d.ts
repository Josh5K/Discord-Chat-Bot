/// <reference types="node" />
import Connection, { ConnectionInfo } from './Connection/Connection';
import Message, { MessageConstructor } from './Message/Message';
import MessageCollector from './Message/MessageCollector';
import Capability, { ServerCapability } from './Capability/Capability';
import { EventEmitter, Listener } from 'typed-event-emitter';
import { PrivateMessage, Notice } from './Message/MessageTypes/Commands';
export declare type EventHandler<T extends Message = Message> = (message: T) => void;
export declare type EventHandlerList<T extends Message = Message> = Map<string, EventHandler<T>>;
export interface SupportedChannelModes {
    list: string;
    alwaysWithParam: string;
    paramWhenSet: string;
    noParam: string;
}
export default class Client extends EventEmitter {
    protected _connection: Connection;
    protected _nick: string;
    protected _userName: string;
    protected _realName: string;
    protected _registered: boolean;
    protected _supportsCapabilities: boolean;
    protected _events: Map<string, EventHandlerList>;
    protected _registeredMessageTypes: Map<string, MessageConstructor<Message>>;
    onConnect: (handler: () => void) => Listener;
    onRegister: (handler: () => void) => Listener;
    onDisconnect: (handler: (reason?: Error) => void) => Listener;
    onPrivmsg: (handler: (target: string, user: string, message: string, msg: PrivateMessage) => void) => Listener;
    onAction: (handler: (target: string, user: string, message: string, msg: PrivateMessage) => void) => Listener;
    onNotice: (handler: (target: string, user: string, message: string, msg: Notice) => void) => Listener;
    onCtcp: (handler: (target: string, user: string, command: string, message: string, msg: PrivateMessage) => void) => Listener;
    onCtcpReply: (handler: (target: string, user: string, command: string, message: string, msg: Notice) => void) => Listener;
    protected _channelTypes: string;
    protected _supportedUserModes: string;
    protected _supportedChannelModes: SupportedChannelModes;
    protected _supportedFeatures: {
        [feature: string]: true | string;
    };
    protected _collectors: MessageCollector[];
    protected _clientCapabilities: Map<string, Capability>;
    protected _serverCapabilities: Map<string, ServerCapability>;
    protected _negotiatedCapabilities: Map<string, ServerCapability>;
    protected _debugLevel: number;
    protected _pingOnInactivity: number;
    protected _pingTimeout: number;
    protected _pingCheckTimer: NodeJS.Timer;
    protected _pingTimeoutTimer: NodeJS.Timer;
    constructor({connection, webSocket, channelTypes, debugLevel}: {
        connection: ConnectionInfo;
        webSocket?: boolean;
        channelTypes?: string;
        debugLevel?: number;
    });
    pingCheck(): void;
    reconnect(message?: string): Promise<void>;
    registerMessageType(cls: MessageConstructor): void;
    knowsCommand(command: string): boolean;
    getCommandClass(command: string): MessageConstructor | undefined;
    protected registerCoreMessageTypes(): void;
    connect(): Promise<void>;
    protected _negotiateCapabilityBatch(capabilities: ServerCapability[][]): Promise<(ServerCapability[] | Error)[]>;
    protected _negotiateCapabilities(capList: ServerCapability[]): Promise<ServerCapability[] | Error>;
    registerCapability(cap: Capability): Promise<Error | ServerCapability[]>;
    send(message: Message): void;
    onMessage<T extends Message>(type: MessageConstructor<T> | string, handler: EventHandler<T>, handlerName?: string): string;
    removeMessageListener(handlerName: string): void;
    createMessage<T extends Message, D>(type: MessageConstructor<T, D>, params: {
        [name in keyof D]?: string;
    }): T;
    sendMessage<T extends Message, D>(type: MessageConstructor<T, D>, params: {
        [name in keyof D]?: string;
    }): void;
    sendMessageAndCaptureReply<T extends Message, D>(type: MessageConstructor<T, D>, params: {
        [name in keyof D]?: string;
    }): Promise<Message[]>;
    readonly channelTypes: string;
    readonly supportedChannelModes: SupportedChannelModes;
    readonly isConnected: boolean;
    readonly isConnecting: boolean;
    readonly isRegistered: boolean;
    collect(originalMessage: Message, ...types: MessageConstructor[]): MessageCollector;
    stopCollect(collector: MessageCollector): void;
    join(channel: string, key?: string): void;
    part(channel: string): void;
    quit(message?: string): Promise<void>;
    private handleEvents(message);
    private _startPingCheckTimer();
}
