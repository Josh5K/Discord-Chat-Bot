"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Message_1 = require("../../Message");
const StringTools_1 = require("../../../Toolkit/StringTools");
class Mode extends Message_1.default {
    get isChannel() {
        return StringTools_1.isChannel(this._parsedParams.target.value, this._client.channelTypes);
    }
    separate() {
        let result = [];
        const modeRestParam = this._parsedParams.modes;
        if (!modeRestParam) {
            throw new Error('can\'t separate a channel mode request, just set actions');
        }
        let modeParams = modeRestParam.value.split(' ');
        const modes = modeParams.shift();
        if (!modes) {
            throw new Error('this should never happen because of the error condition above');
        }
        let currentModeAction = 'add';
        for (let ch of modes) {
            let thisModeAction = currentModeAction;
            switch (ch) {
                case '+': {
                    currentModeAction = 'add';
                    break;
                }
                case '-': {
                    currentModeAction = 'remove';
                    break;
                }
                default: {
                    let requiresParam = false;
                    if (this.isChannel) {
                        if (this._client.supportedChannelModes.alwaysWithParam.includes(ch)) {
                            requiresParam = true;
                        }
                        else if (this._client.supportedChannelModes.paramWhenSet.includes(ch)) {
                            if (currentModeAction === 'add') {
                                requiresParam = true;
                            }
                        }
                        else if (this._client.supportedChannelModes.list.includes(ch)) {
                            if (modeParams.length) {
                                requiresParam = true;
                            }
                            else {
                                thisModeAction = 'getList';
                            }
                        }
                        else if (this._client.supportedChannelModes.noParam.includes(ch)) {
                            // whatever
                        }
                        else {
                            throw new Error(`unknown mode character: ${ch}`);
                        }
                    }
                    if (requiresParam && !modeParams.length) {
                        throw new Error(`mode parameter underflow`);
                    }
                    result.push({
                        prefix: this._prefix,
                        action: thisModeAction,
                        mode: ch,
                        param: requiresParam ? modeParams.shift() : undefined
                    });
                }
            }
        }
        return result;
    }
}
Mode.COMMAND = 'MODE';
Mode.PARAM_SPEC = {
    target: {},
    modes: {
        rest: true,
        optional: true
    }
};
exports.default = Mode;
//# sourceMappingURL=Mode.js.map