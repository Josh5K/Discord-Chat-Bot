"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ObjectTools_1 = require("../Toolkit/ObjectTools");
const StringTools_1 = require("../Toolkit/StringTools");
class MessageParam {
    constructor(value, trailing) {
        this.value = value;
        this.trailing = trailing;
    }
}
exports.MessageParam = MessageParam;
const tagEscapeMap = {
    '\\': '\\',
    ':': ';',
    n: '\n',
    r: '\r',
    s: ' '
};
class Message {
    constructor(client, command, params, tags, prefix) {
        this._params = [];
        this._command = command;
        this._params = params;
        this._tags = tags;
        this._prefix = prefix;
        Object.defineProperty(this, '_client', {
            get: () => {
                return client;
            }
        });
        this.parseParams();
    }
    static parse(line, client) {
        const splitLine = line.split(' ');
        let token;
        let command;
        let params = [];
        let tags;
        let prefix;
        while ((token = splitLine[0]) !== undefined) {
            if (token[0] === '@' && !tags && !command) {
                tags = Message.parseTags(token.substr(1));
            }
            else if (token[0] === ':') {
                if (!prefix && !command) {
                    prefix = Message.parsePrefix(token.substr(1));
                }
                else {
                    params.push(new MessageParam(splitLine.join(' ').substr(1), true));
                    break;
                }
            }
            else if (!command) {
                command = token.toUpperCase();
            }
            else {
                params.push(new MessageParam(token, false));
            }
            splitLine.shift();
        }
        if (!command) {
            throw new Error(`line without command received: ${line}`);
        }
        let message;
        let messageClass = Message;
        if (client.knowsCommand(command)) {
            messageClass = client.getCommandClass(command);
        }
        message = new messageClass(client, command, params, tags, prefix);
        message._raw = line;
        return message;
    }
    static parsePrefix(raw) {
        const [nick, hostName] = raw.split('!', 2);
        if (hostName) {
            let [user, host] = hostName.split('@', 2);
            if (host) {
                return { raw, nick, user, host };
            }
            else {
                return { raw, nick, host: user };
            }
        }
        else {
            return { raw, nick };
        }
    }
    static parseTags(raw) {
        let tags = new Map();
        const tagStrings = raw.split(';');
        for (const tagString of tagStrings) {
            const [tagName, tagValue] = tagString.split('=', 2);
            // unescape according to http://ircv3.net/specs/core/message-tags-3.2.html#escaping-values
            tags.set(tagName, tagValue.replace(/\\([\\:nrs])/g, (_, match) => tagEscapeMap[match]));
        }
        return tags;
    }
    // noinspection JSUnusedGlobalSymbols
    static create(client, params) {
        let message = new this(client, this.COMMAND);
        let parsedParams = {};
        for (let [paramName, paramSpec] of Object.entries(this.PARAM_SPEC)) {
            if (paramName in params) {
                const param = params[paramName];
                if (param !== undefined) {
                    if (this.checkParam(client, param, paramSpec)) {
                        parsedParams[paramName] = new MessageParam(param, Boolean(paramSpec.trailing));
                    }
                    else if (!paramSpec.optional) {
                        throw new Error(`required parameter "${paramName}" did not suit requirements: "${param}"`);
                    }
                }
            }
            if (!(paramName in parsedParams) && !paramSpec.optional) {
                throw new Error(`required parameter "${paramName}" not found in command "${this.COMMAND}"`);
            }
        }
        message._parsedParams = parsedParams;
        return message;
    }
    static checkParam(client, param, spec) {
        if (spec.type === 'channel') {
            if (!StringTools_1.isChannel(param, client.channelTypes)) {
                return false;
            }
        }
        if (spec.match) {
            if (!spec.match.test(param)) {
                return false;
            }
        }
        return true;
    }
    toString() {
        const cls = this.constructor;
        const specKeys = Object.keys(cls.PARAM_SPEC);
        return [this._command, ...specKeys.map((paramName) => {
                const param = this._parsedParams[paramName];
                if (param instanceof MessageParam) {
                    return (param.trailing ? ':' : '') + param.value;
                }
            }).filter((param) => param !== undefined)].join(' ');
    }
    parseParams() {
        if (this._params) {
            const cls = this.constructor;
            let requiredParamsLeft = cls.minParamCount;
            if (requiredParamsLeft > this._params.length) {
                throw new Error(`command "${this._command}" expected ${requiredParamsLeft} or more parameters, got ${this._params.length}`);
            }
            const paramSpecList = cls.PARAM_SPEC;
            let i = 0;
            let parsedParams = {};
            for (let [paramName, paramSpec] of Object.entries(paramSpecList)) {
                if ((this._params.length - i) <= requiredParamsLeft) {
                    if (paramSpec.optional) {
                        continue;
                    }
                    else if (this._params.length - i !== requiredParamsLeft) {
                        throw new Error('not enough parameters left for required parameters parsing (this is a library bug)');
                    }
                }
                let param = this._params[i];
                if (!param) {
                    if (paramSpec.optional) {
                        break;
                    }
                    throw new Error(`unexpected parameter underflow`);
                }
                if (paramSpec.rest) {
                    let restParams = [];
                    while (this._params[i] && !this._params[i].trailing) {
                        restParams.push(this._params[i].value);
                        ++i;
                    }
                    if (!restParams.length) {
                        if (paramSpec.optional) {
                            continue;
                        }
                        throw new Error(`no parameters left for required rest parameter "${paramName}"`);
                    }
                    param = new MessageParam(restParams.join(' '), false);
                }
                if (this.checkParam(param.value, paramSpec)) {
                    parsedParams[paramName] = new MessageParam(param.value, param.trailing);
                    if (!paramSpec.optional) {
                        --requiredParamsLeft;
                    }
                    if (!paramSpec.rest) {
                        ++i;
                    }
                }
                else if (!paramSpec.optional) {
                    throw new Error(`required parameter "${paramName}" (index ${i}) did not suit requirements: "${param.value}"`);
                }
                if (paramSpec.trailing) {
                    break;
                }
            }
            this._parsedParams = parsedParams;
        }
    }
    checkParam(param, spec) {
        const cls = this.constructor;
        return cls.checkParam(this._client, param, spec);
    }
    // noinspection JSUnusedGlobalSymbols
    static get minParamCount() {
        return Object.values(this.PARAM_SPEC).filter((spec) => !spec.optional).length;
    }
    // WS doesn't pick this up in destructuring, so we need to turn off the inspection
    // noinspection JSUnusedGlobalSymbols
    get params() {
        return ObjectTools_1.default.map(this._parsedParams, (param) => param.value);
    }
    get prefix() {
        return Object.assign({}, this._prefix);
    }
    get command() {
        return this._command;
    }
    get tags() {
        return new Map(this._tags || []);
    }
    send() {
        this._client.send(this);
    }
    sendAndCaptureReply() {
        return __awaiter(this, void 0, void 0, function* () {
            const cls = this.constructor;
            if (!cls.SUPPORTS_CAPTURE) {
                throw new Error(`The command "${cls.COMMAND}" does not support reply capture`);
            }
            const promise = this._client.collect(this).promise();
            this.send();
            return promise;
        });
    }
    isResponseTo(originalMessage) {
        return false;
    }
    endsResponseTo(originalMessage) {
        return false;
    }
    _acceptsInReplyCollection(message) {
        // TODO implement IRCv3 labeled-response / batch here
        return message.isResponseTo(this);
    }
}
Message.COMMAND = '';
Message.PARAM_SPEC = {};
//noinspection JSUnusedGlobalSymbols
Message.SUPPORTS_CAPTURE = false;
exports.default = Message;
//# sourceMappingURL=Message.js.map