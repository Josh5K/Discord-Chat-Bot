"use strict";
Object.defineProperty(exports, "__esModule", {value: true});
const Numerics_1 = require("./MessageTypes/Numerics");
const Numeric461NeedMoreParams_1 = require("./MessageTypes/Numerics/Numeric461NeedMoreParams");

class MessageCollector {
	constructor(_client, _originalMessage,

...
	types
) {
	this
.
	_client = _client;
	this
.
	_originalMessage = _originalMessage;
	this
.
	_messages = [];
	this
.
	_endEventHandlers = new Map();
	this
.
	_additionalCondition = () =
>
	false;
	this
.
	_endCondition = () =
>
	true;
	this
.
	_types = new Set(types);
}

addType(...types
)
{
	types.forEach(type = > this._types.add(type)
)
	;
}
untilType(...types
)
{
	this.addType(...types
)
	;
	return this.until((message) = > {
		return types.some(type = > message instanceof type
)
	;
})
	;
}
until(condition)
{
	this._endCondition = condition;
	return this;
}
untilEvent(eventType)
{
	this._cleanEndEventHandler(eventType);
	this._endEventHandlers.set(eventType, () = > this.end()
)
	;
}
promise()
{
	if (!this._promise) {
		this._promise = new Promise(resolve = > this._promiseResolve = resolve
	)
		;
	}
	return this._promise;
}
intercept(message)
{
	let genericError = false;
	let isInterceptedType = false;
	// special case: if we get a generic error reply to this, always abort, even if the consumer did not request
	// that - there's a generic problem with the command, e.g. the command not existing or not having all required
	// parameters, and trying to wait for the actual replies would break shit (and probably lead to huge
	// amounts of memory leaks)
	if (this._isMatchingGenericError(message)) {
		genericError = true;
	}
	else {
		isInterceptedType = this._types.has(message.constructor);
		if (!this._additionalCondition(message, this) && !isInterceptedType) {
			return false;
		}
	}
	this._messages.push(message);
	// we'd use genericError first for short circuit, but the end condition might have some strange handler code
	// that's supposed to fire on every message received as reply
	if (this._endCondition(message, this) || genericError) {
		this.end();
	}
	return isInterceptedType || genericError;
}
end()
{
	this._client.stopCollect(this);
	this._cleanEndEventHandlers();
	if (this._promiseResolve) {
		this._promiseResolve(this._messages);
	}
}
_isMatchingGenericError(message)
{
	if (!(message instanceof Numerics_1.Numeric421UnknownCommand || message instanceof Numeric461NeedMoreParams_1.default)) {
		return false;
	}
	return this._originalMessage.command === message.params.command;
}
_cleanEndEventHandlers()
{
	this._endEventHandlers.forEach((handler, type) = > this._client.removeListener(type, handler)
)
	;
	this._endEventHandlers.clear();
}
_cleanEndEventHandler(eventType)
{
	if (this._endEventHandlers.has(eventType)) {
		this._client.removeListener(eventType, this._endEventHandlers.get(eventType));
		this._endEventHandlers.delete(eventType);
	}
}
}
exports.default = MessageCollector;
//# sourceMappingURL=MessageInterceptor.js.map
